src/render/user_interface.c:	img->ptr = mlx_new_image(specs->mlx, POS_X, HEIGHT);
src/render/user_interface.c:	mlx_put_image_to_window(specs->mlx, specs->win, img.ptr, 0, 0);
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 50, WHITE, "CAMERA MOVEMENTS :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 50, RED, "OFF");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 100, WHITE, "ALLOW CAMERA MOVEMENT :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 100, GREEN, "SPACE");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 150, WHITE, "ANTI ALIASING :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 150, GREEN, "L");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 200, WHITE, "FILTER SEPIA : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 200, GREEN, "S");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 250, WHITE, "FILTER GRAY : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 250, GREEN, "A");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 300, WHITE, "FILTER BLUE : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 300, GREEN, "F");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 350, WHITE, "FILTER GREEN : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 350, GREEN, "G");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 400, WHITE, "FILTER PURPLE : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 400, GREEN, "H");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 50, WHITE, "CAMERA MOVEMENTS :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 50, GREEN, "ON");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 100, WHITE, "NATIVE MODE :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 100, GREEN, "SPACE");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 150, WHITE, "ANTI ALIASING :");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 150, GREEN, "L");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 200, WHITE, "MOVE CAMERA POSITION : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 200, GREEN, "ARROW KEYS");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 20, 250, WHITE, "MOVE CAMERA DIRECTION : ");
src/render/user_interface.c:	mlx_string_put(specs->mlx, specs->win, 200, 250, GREEN, "LEFT MOUSE CLICK");
src/render/cone.c:	tmp = vec3_scale(specs->axis, height, '*');
src/render/cone.c:	tmp2 = vec3_add(specs->center, tmp, '+');
src/render/cone.c:	hplus = tan(specs->angle) * dist;
src/render/cone.c:	tmp = vec3_scale(specs->axis, height, '*');
src/render/cone.c:	tmp2 = vec3_add(specs->center, tmp, '+');
src/render/cone.c:	sect[2] = vec3_add(sect[0], specs->center, '-');
src/render/cone.c:	if ((hi[0] = vec3_dot(sect[2], specs->axis)) > specs->max ||
src/render/cone.c:						hi[0] < specs->min)
src/render/cone.c:	sect[3] = vec3_add(sect[1], specs->center, '-');
src/render/cone.c:	if ((hi[1] = vec3_dot(sect[3], specs->axis)) > specs->max ||
src/render/cone.c:						hi[1] < specs->min)
src/render/cone.c:		ray->surf = specs->surf;
src/render/cone.c:	oc = vec3_add(ray->origin, specs->center, '-');
src/render/cone.c:	abc[0] = pow(vec3_dot(ray->direct, specs->axis), 2)
src/render/cone.c:			- pow(cos(specs->angle), 2);
src/render/cone.c:	abc[1] = 2 * ((vec3_dot(ray->direct, specs->axis)
src/render/cone.c:			* vec3_dot(oc, specs->axis)) - (vec3_dot(ray->direct, oc)
src/render/cone.c:				* pow(cos(specs->angle), 2)));
src/render/cone.c:	abc[2] = pow(vec3_dot(oc, specs->axis), 2) - (vec3_dot(oc, oc)
src/render/cone.c:			* pow(cos(specs->angle), 2));
src/render/texture.c:	offset = (((int)(u * specs->textures[index]->width) + (int)(v * specs->textures[index]->height) * specs->textures[index]->width));
src/render/texture.c:	ft_memcpy((void *)&color, (void *)specs->textures[index]->data + (offset * 4), 4);
src/render/event.c:	img->ptr = mlx_xpm_file_to_image(specs->mlx, path, &img->width, &img->height);
src/render/event.c:	specs->textures[0] = create_image(specs, "textures/posx.xpm");
src/render/event.c:	specs->textures[1] = create_image(specs, "textures/negx.xpm");
src/render/event.c:	specs->textures[2] = create_image(specs, "textures/posy.xpm");
src/render/event.c:	specs->textures[3] = create_image(specs, "textures/negy.xpm");
src/render/event.c:	specs->textures[4] = create_image(specs, "textures/posz.xpm");
src/render/event.c:	specs->textures[5] = create_image(specs, "textures/negz.xpm");
src/render/event.c:		v.red = ft_min(255.0, (((unsigned char)specs->img_str2[i + 2] * .393) + ((unsigned char)specs->img_str2[i + 1] * .769) + ((unsigned char)specs->img_str2[i] * .189)));
src/render/event.c:		v.green = ft_min(255.0, (((unsigned char)specs->img_str2[i + 2] * .349) + ((unsigned char)specs->img_str2[i + 1] * .686) + ((unsigned char)specs->img_str2[i] * .168)));
src/render/event.c:		v.blue = ft_min(255.0, (((unsigned char)specs->img_str2[i + 2] * .272) + ((unsigned char)specs->img_str2[i + 1] * .534) + ((unsigned char)specs->img_str2[i] * .131)));
src/render/event.c:		specs->img_str2[i + 2] = v.red;
src/render/event.c:		specs->img_str2[i + 1] = v.green;
src/render/event.c:		specs->img_str2[i] = v.blue;
src/render/event.c:		gray = (int)(((unsigned char)specs->img_str2[i + 2] * 0.3) + ((unsigned char)specs->img_str2[i + 1] * 0.59) + ((unsigned char)specs->img_str2[i] * 0.11));
src/render/event.c:		specs->img_str2[i + 2] = gray;
src/render/event.c:		specs->img_str2[i + 1] = gray;
src/render/event.c:		specs->img_str2[i] = gray;
src/render/event.c:		gray = (int)(((unsigned char)specs->img_str2[i + 2] * 0.3) + ((unsigned char)specs->img_str2[i + 1] * 0.59) + ((unsigned char)specs->img_str2[i] * 0.11));
src/render/event.c:		specs->img_str2[i + 2] = 0;
src/render/event.c:		specs->img_str2[i + 1] = gray;
src/render/event.c:		specs->img_str2[i] = gray;
src/render/event.c:		gray = (int)(((unsigned char)specs->img_str2[i + 2] * 0.3) + ((unsigned char)specs->img_str2[i + 1] * 0.59) + ((unsigned char)specs->img_str2[i] * 0.11));
src/render/event.c:		specs->img_str2[i + 2] = gray;
src/render/event.c:		specs->img_str2[i + 1] = gray;
src/render/event.c:		specs->img_str2[i] = 0;
src/render/event.c:		gray = (int)(((unsigned char)specs->img_str2[i + 2] * 0.3) + ((unsigned char)specs->img_str2[i + 1] * 0.59) + ((unsigned char)specs->img_str2[i] * 0.11));
src/render/event.c:		specs->img_str2[i + 2] = 0;
src/render/event.c:		specs->img_str2[i + 1] = gray;
src/render/event.c:		specs->img_str2[i] = 0;
src/render/event.c:			v.coord[0] = (j * 8) + (i * 2) * specs->size_line;
src/render/event.c:			v.coord[1] = (j * 8) + 4 + (i * 2) * specs->size_line;
src/render/event.c:			v.coord[2] = (j * 8) + ((i * 2) + 1) * specs->size_line;
src/render/event.c:			v.coord[3] = (j * 8) + 4  + ((i * 2) + 1) * specs->size_line;
src/render/event.c:			ft_memcpy(&v.pix[0], specs->img_str + v.coord[0], 4);
src/render/event.c:			ft_memcpy(&v.pix[1], specs->img_str + v.coord[1], 4);
src/render/event.c:			ft_memcpy(&v.pix[2], specs->img_str + v.coord[2], 4);
src/render/event.c:			ft_memcpy(&v.pix[3], specs->img_str + v.coord[3], 4);
src/render/event.c:			v.coord[4] = i * specs->size_line2 + (j * 4);
src/render/event.c:			specs->img_str2[v.coord[4]] = (((v.pix[0] & 0xff) + (v.pix[1] & 0xff) + (v.pix[2] & 0xff) + (v.pix[3] & 0xff)) / 4);
src/render/event.c:			specs->img_str2[v.coord[4] + 1] = ((((v.pix[0] >> 8) & 0xff) + ((v.pix[1] >> 8) & 0xff) + ((v.pix[2] >> 8) & 0xff) + ((v.pix[3] >> 8) & 0xff)) / 4);
src/render/event.c:			specs->img_str2[v.coord[4] + 2] = ((((v.pix[0] >> 16) & 0xff) + ((v.pix[1] >> 16) & 0xff) + ((v.pix[2] >> 16) & 0xff) + ((v.pix[3] >> 16) & 0xff)) / 4);
src/render/event.c:	while (i < specs->h_img)
src/render/event.c:		while (j < specs->w_img)
src/render/event.c:			v.coord[4] = (j * 4) + i * specs->size_line;
src/render/event.c:			ft_memcpy(&v.pix[0], specs->img_str + v.coord[4], 4);
src/render/event.c:			v.coord[0] = (j * 8) + i * 2 * specs->size_line2 ;
src/render/event.c:			v.coord[2] = (j * 8) + ((i * 2) + 1) * specs->size_line2;
src/render/event.c:			specs->img_str2[v.coord[0]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[0] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[0] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:	specs->img_str2[coord] = pix & 0xff;
src/render/event.c:	specs->img_str2[coord + 1] = (pix >> 8) & 0xff;
src/render/event.c:	specs->img_str2[coord + 2] = (pix >> 16) & 0xff;
src/render/event.c:	while (i < specs->h_img)
src/render/event.c:		while (j < specs->w_img)
src/render/event.c:			v.coord[16] = (j * 4) + i * specs->size_line;
src/render/event.c:			ft_memcpy(&v.pix[0], specs->img_str + v.coord[16], 4);
src/render/event.c:			v.coord[0] = (j * 16) + i * 4 * specs->size_line2 ;
src/render/event.c:			v.coord[4] = (j * 16) + ((i * 4) + 1) * specs->size_line2;
src/render/event.c:			v.coord[8] = (j * 16) + ((i * 4) + 2) * specs->size_line2;
src/render/event.c:			v.coord[12] = (j * 16) + ((i * 4) + 3) * specs->size_line2;
src/render/event.c:			specs->img_str2[v.coord[0]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[0] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[0] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[1] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[2] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3]] = v.pix[0] & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3] + 1] = (v.pix[0] >> 8) & 0xff;
src/render/event.c:			specs->img_str2[v.coord[3] + 2] = (v.pix[0] >> 16) & 0xff;
src/render/event.c:	specs->w_img = W_IMG * 2;
src/render/event.c:	specs->h_img = H_IMG * 2;
src/render/event.c:	if (!(specs->img = mlx_new_image(specs->mlx, specs->w_img, specs->h_img)))
src/render/event.c:	if (!(specs->img_str = mlx_get_data_addr(specs->img, &specs->bpp,
src/render/event.c:	&specs->size_line, &specs->endian)))
src/render/event.c:	if (!(specs->img2 = mlx_new_image(specs->mlx, W_IMG, H_IMG)))
src/render/event.c:	if (!(specs->img_str2 = mlx_get_data_addr(specs->img2, &specs->bpp,
src/render/event.c:	&specs->size_line2, &specs->endian)))
src/render/event.c:	mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:	specs->w_img = W_IMG / 2;
src/render/event.c:	specs->h_img = H_IMG / 2;
src/render/event.c:	if (!(specs->img = mlx_new_image(specs->mlx, specs->w_img, specs->h_img)))
src/render/event.c:	if (!(specs->img_str = mlx_get_data_addr(specs->img, &specs->bpp,
src/render/event.c:	&specs->size_line, &specs->endian)))
src/render/event.c:	if (!(specs->img2 = mlx_new_image(specs->mlx, W_IMG, H_IMG)))
src/render/event.c:	if (!(specs->img_str2 = mlx_get_data_addr(specs->img2, &specs->bpp,
src/render/event.c:	&specs->size_line2, &specs->endian)))
src/render/event.c:	mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:	specs->w_img = W_IMG / 4;
src/render/event.c:	specs->h_img = H_IMG / 4;
src/render/event.c:	if (!(specs->img = mlx_new_image(specs->mlx, specs->w_img, specs->h_img)))
src/render/event.c:	if (!(specs->img_str = mlx_get_data_addr(specs->img, &specs->bpp,
src/render/event.c:	&specs->size_line, &specs->endian)))
src/render/event.c:	if (!(specs->img2 = mlx_new_image(specs->mlx, W_IMG, H_IMG)))
src/render/event.c:	if (!(specs->img_str2 = mlx_get_data_addr(specs->img2, &specs->bpp,
src/render/event.c:	&specs->size_line2, &specs->endian)))
src/render/event.c:	mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:	specs->w_img = W_IMG;
src/render/event.c:	specs->h_img = H_IMG;
src/render/event.c:	if (!(specs->img = mlx_new_image(specs->mlx, W_IMG, H_IMG)))
src/render/event.c:	if (!(specs->img_str = mlx_get_data_addr(specs->img, &specs->bpp,
src/render/event.c:	&specs->size_line, &specs->endian)))
src/render/event.c:	mlx_put_image_to_window(specs->mlx, specs->win, specs->img, POS_X, POS_Y);
src/render/event.c:	if (specs->event == NO_EVENT)
src/render/event.c:		mlx_string_put(specs->mlx, specs->win, 100, 300, WHITE, "LOADING..");
src/render/event.c:	if (specs->event == NO_EVENT)
src/render/event.c:		mlx_string_put(specs->mlx, specs->win, 100, 300, WHITE, "LOADING...");
src/render/event.c:		specs->camera.x -= 1.25;
src/render/event.c:		specs->camera.x += 1.25;
src/render/event.c:		specs->camera.y -= 1.25;
src/render/event.c:		specs->camera.y += 1.25;
src/render/event.c:		mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:		mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:		mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:		mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:		mlx_put_image_to_window(specs->mlx, specs->win, specs->img2, POS_X, POS_Y);
src/render/event.c:	if (specs->event == EVENT)
src/render/event.c:		specs->event = !specs->event;
src/render/event.c:		mlx_string_put(specs->mlx, specs->win, 100, 300, WHITE, "LOADING...");
src/render/event.c:		specs->event = NO_EVENT;
src/render/event.c:	if (button == M_CLK_L && specs->event == EVENT)
src/render/event.c:		specs->first = 0;
src/render/event.c:		xm = ((2.0 * (double)(x - POS_X) / W_IMG) - 1.0) * specs->alpha * specs->aspect;
src/render/event.c:		ym = (1.0 - (2.0 * (double)y / H_IMG)) * specs->alpha;
src/render/event.c:		specs->view_dir.x = xm;
src/render/event.c:		specs->view_dir.y = ym;
src/render/event.c:		specs->view_dir.z = -1.0;
src/render/event.c:		specs->view_dir = normalise(specs->view_dir);
src/render/event.c:		specs->view_dir = vector_matrix_multiply(specs->view_dir, specs->view_rot);
src/render/ft_thread.c:		.y_end = specs->h_img / n, .specs = specs};
src/render/ft_thread.c:		.y_end = (i + 1) * specs->h_img / n, .specs = specs};
src/render/lighting.c:	specs->x = specs->x;
src/render/lighting.c:	l = specs->light_list;
src/render/cylinder.c:	sect[2] = vec3_add(sect[0], specs->center, '-');
src/render/cylinder.c:	if ((hi[0] = vec3_dot(sect[2], specs->axis)) > specs->max || hi[0] < 0)
src/render/cylinder.c:	sect[3] = vec3_add(sect[1], specs->center, '-');
src/render/cylinder.c:	if ((hi[1] = vec3_dot(sect[3], specs->axis)) > specs->max || hi[1] < 0)
src/render/cylinder.c:		ray->surf = specs->surf;
src/render/cylinder.c:		sect[2] = vec3_add(specs->center, vec3_scale(specs->axis, hi[0],
src/render/cylinder.c:	oc = vec3_add(ray->origin, specs->center, '-');
src/render/cylinder.c:	abc[0] = 1 - (vec3_dot(ray->direct, specs->axis) * vec3_dot(ray->direct,
src/render/cylinder.c:			specs->axis));
src/render/cylinder.c:			specs->axis) * vec3_dot(oc, specs->axis)));
src/render/cylinder.c:	abc[2] = vec3_dot(oc, oc) - (vec3_dot(oc, specs->axis) *
src/render/cylinder.c:			vec3_dot(oc, specs->axis)) - (specs->radius * specs->radius);
src/render/cap.c:	v.p.point = specs->center;
src/render/cap.c:	v.p.normal = specs->axis;
src/render/cap.c:	v.p.surf = specs->surf;
src/render/cap.c:	if (v.t < ray->t && v.t > NEAR && v.dist < specs->radius)
src/render/cap.c:	v.p.point = vec3_scale(specs->axis, specs->max, '*');
src/render/cap.c:	v.p.point = vec3_add(specs->center, v.p.point, '+');
src/render/cap.c:	v.p.normal = specs->axis;
src/render/cap.c:	v.p.surf = specs->surf;
src/render/cap.c:	if (v.t < ray->t && v.t > NEAR && v.dist < specs->radius)
src/render/cap.c:	v.p.point = vec3_scale(specs->axis, specs->min, '*');
src/render/cap.c:	v.p.point = vec3_add(specs->center, v.p.point, '+');
src/render/cap.c:	v.p.normal = specs->axis;
src/render/cap.c:	v.p.surf = specs->surf;
src/render/cap.c:	v.rad = tan(specs->angle) * ft_abs(specs->min);
src/render/cap.c:	v.p.point = vec3_scale(specs->axis, specs->max, '*');
src/render/cap.c:	v.p.point = vec3_add(specs->center, v.p.point, '+');
src/render/cap.c:	v.p.normal = specs->axis;
src/render/cap.c:	v.p.surf = specs->surf;
src/render/cap.c:	v.rad = tan(specs->angle) * ft_abs(specs->max);
src/render/initialise.c:			mlx_destroy_window(specs->mlx, specs->win);
src/render/initialise.c:		mlx_destroy_window(specs->mlx, specs->win);
src/render/initialise.c:	specs->nb_line = count;
src/render/initialise.c:	if (!(specs->input = (char **)malloc(sizeof(char *)
src/render/initialise.c:		free_array(specs->input, FAIL, specs, NULL);
src/render/initialise.c:			free_array(specs->input, i, specs, line);
src/render/initialise.c:		if (!(specs->input[++i] = (char *)malloc(sizeof(char) *
src/render/initialise.c:			free_array(specs->input, i, specs, line);
src/render/initialise.c:			specs->input[i][j] = line[j];
src/render/initialise.c:		specs->input[i][ft_strlen(line)] = '\0';
src/render/initialise.c:	specs->input[i + 1] = NULL;
src/render/ray_utils.c:	if (specs->first++ == 0)
src/render/ray_utils.c:		specs->view_rot = rot_from_base(specs->view_dir, base, 0);
src/render/ray_utils.c:		//specs->alpha = tan(specs->alpha / 2);
src/render/ray_utils.c:	ray.x = ((2.0 * x) - 1.0) * specs->alpha * specs->aspect;
src/render/ray_utils.c:	ray.y = (1.0 - (2.0 * y)) * specs->alpha;
src/render/ray_utils.c:	ray = vector_matrix_multiply(ray, specs->view_rot);
src/render/ray_utils.c:	o = specs->obj_list;
src/render/ray_utils.c:		specs->fct_ptr[o->id](specs, ray, o->obj);
src/render/ray_utils.c:	o = specs->obj_list;
src/render/ray_utils.c:		specs->fct_ptr[o->id](specs, ray, o->obj);
src/render/main.c:	ray.origin = specs->camera;
src/render/main.c:	ray.direct = pixel_to_world((float)x / specs->w_img, (float)y / specs->h_img, specs);
src/render/main.c:		while (++x < d->specs->w_img)
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4] = specs->far_col & 0xff;
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4 + 1] =
src/render/colouring.c:			(specs->far_col >> 8) & 0xff;
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4 + 2] =
src/render/colouring.c:			(specs->far_col >> 16) & 0xff;
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4] = b;
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4 + 1] = g;
src/render/colouring.c:	specs->img_str[(y * specs->w_img + x) * 4 + 2] = r;
